\chapter{Inductive statements for regular transition system}\label{chapter:inductive_statement}
\paragraph*{}
In the \textit{Regular Model Checking} framework, program configurations are 
represented as finite words over a pre-determined alphabet $\Sigma$.
The system comprises a series of starting configurations and the transitions
are modelled as the relations
mapping configuations to configuations.
In \autoref{section:rts}, we introduce \textit{Regular transition system} (RTS)
—an important framework for infinite state model-checking
—to represent the behavior of a system.
\autoref{section:inductive_statements} will explain how to encode a inductive statement.
In addition, we will be presenting the three interpretations that we have utilized in this thesis.

\section{Regular transition system}\label{section:rts}
Essentially, a \textit{regular transition system} represents a parameterized system $\mathcal{S}$.
For example, a \textit{token-passing} system $\mathcal{S}$ with n is the number
of agents. We call $\Sigma$ is the set of alphabets of the system, which indicates the finite states of the agent. 
For $\mathcal{S}$, $\Sigma = \{n, t\}$.
The system begins with initial configurations, defined by a regular language.
A sequence of alphabets represents the corresponding state of the agents.
In other words, one can understand that the first letter indicates the state $u_1 \in \Sigma$ of the first agent, 
the second letter indicates the state $u_2 \in \Sigma$ of the second agent, and so on.
The states of each agent can be changed by following the system's rules,
called the relations. Formally, we call that a \textit{transducer} and define these relations in the form of an NFA as follows:
\begin{theo}[Transducer]{definition:transducer}
    \textit{
        A $\Sigma$-$\Gamma$-\textit{transducer} $\mathcal{T}$ is an \textit{NFA} 
        $\langle Q, Q_0, \Sigma \times \Gamma, \Delta, F \rangle$,
        we denote a relation 
        \begin{equation*}
          [[\mathcal{T}]] = \lbrace \langle u_1 \dots u_n, v_1 \dots v_n \rangle \in \bigcup_{n \geq 0} \Sigma^{n} \times \Gamma^{n} 
          \,\,|\,\, \langle u_1, v_1 \rangle \dots \langle u_n, v_n \rangle \in \mathcal{L}(\mathcal{T}) \rbrace 
        \end{equation*}
        Note that this relationship is only applicable to words that have the same length.
        Extend this notation, we define
        \begin{align*} 
            For \,\, v \in \Sigma^*: target_{\mathcal{T}}(v) = \lbrace u \in \Gamma^*\,\, | \,\, \langle v,u \rangle \in [[\mathcal{T}]] \rbrace 
        \end{align*}
    }
\end{theo}
\begin{lem}[Transducer $\Gamma$ for Token passing]{lem:transducer}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (p_0)   {$p_0$}; 
        \node[state] (p_1) [right=of p_0] {$p_1$}; 
        \node[state,accepting] (p_2) [right=of p_1] {$p_2$}; 
         \path[->] 
         (p_0) edge  node {$[t, n]$} (p_1)
               edge [loop above] node {$[n, n]$} ()
         (p_1) edge  node {$[n, t]$} (p_2)
         (p_2) edge [loop above] node {$[n, n]$} ();
     \end{tikzpicture}
\end{lem}

\paragraph*{}
Automaton \ref{lem:transducer} indicates that the token will be transferred from the left agent to the right agent. 
Once the token reaches the end of the agents, no further transitions can be made to the configuration.
We capture the transitions of the \textit{token passing} system via the language 
$[n,n]^*[t,n][n,t][n,n]^*$.
Consider the following scenario: "n n t n" represents a system with four agents, 
where the third agent currently holds the token. In the next step, 
only the third agent can transfer the token to the agent on the right. 
This can be represented as "n n n t". The system terminates since the last agent 
holds the token.

\begin{theo}[Regular transition system (RTS)]{definition:rts}
    \textit{
    An RTS is a triple $\mathcal{R} = \langle \Sigma, \mathcal{I}, \mathcal{T} \rangle$ where $\Sigma$
    is finite alphabet and $\mathcal{I}$ is an NFA, which represents initial configurations.
    $\mathcal{T}$ is a $\Sigma$-$\Sigma$-\textit{transducer} of the system.
    }
\end{theo}

We denote with $\rightsquigarrow_\mathcal{T}$ the relation $[[\mathcal{T}]]$ and call
a pair $\langle u, v \rangle$ $\in$ $\rightsquigarrow_\mathcal{T}$ a transition of $\mathcal{R}$.
Moreover, let $\rightsquigarrow_\mathcal{T}^{*}$ denote the reflexive
transitive closure of $\rightsquigarrow_\mathcal{T}$.
We consider $w \in \Sigma^*$ \textit{reachable} on $\mathcal{R}$
if there exist $u \in \mathcal{L}(\mathcal{I})$ with $u \rightsquigarrow_\mathcal{T}^{*} v$.
Let \textit{reach}$(\mathcal{R}) \subseteq \Sigma^*$ denotes all
reachable configurations.
\begin{lem}[NFA $\mathcal{I}$ for Token passing]{lem:bezout}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (q_0)   {$q_0$}; 
        \node[state,accepting] (q_1) [right=of q_0] {$q_1$}; 
         \path[->] 
         (q_0) edge  node {t} (q_1)
         (q_1) edge [loop above] node {n} ();
     \end{tikzpicture}
\end{lem}

\paragraph*{}
$\mathcal{L}(\mathcal{I})$ defines the set of initial configurations for the \textit{token passing} 
as tn*.
In other words, the first agent always holds the token, while the following agents do not.

\section{Inductive statements}\label{section:inductive_statements}
In general, we need to determine if a given RTS can produce any undesirable word,
which is pre-defined in a reglar set.
We call this a \textit{Reachability problem}.
\subsection*{Reachability problem}
Besides the \textit{RTS} $\mathcal{R}$, an automaton $\mathcal{B}$ for the regular language that denotes the undesired configurations has been provided.
The question at hand is whether it is possible to achieve any undesired configuration in this particular transition system.
Formally, we have to compute
if \textit{reach}($\mathcal{R}$)
$\bigcap$ $\mathcal{L}(\mathcal{B}) = \emptyset?$
Because the reachability problem is undecidable, a new approach is needed to 
ensure no undesired configurations are reached.
We are exploring whether there exists a pair of configurations, $v$ and $u$, 
where $u$ satisfies all the inductive statements that $v$ satisfies. 
Indeed, if $u$ is reachable from $v$, then it will satisfy all the same inductive statements that $v$ did since they are inductive.
This method can be used to determine whether an undesired configuration can be reached 
from an initial configuration. 
If there is (at least) an inductive statement that $v$ satisfies, but $u$ does not, then it is not possible to reach $u$ from $v$.

\subsection*{Encoded statements}
We shall now proceed to examine the process of how the statements are encoded.
We consider the statement pattern "in all configuations of a certain length
m either agent $i_1$ is in state $\sigma_1$ or agent $i_2$ is in state
$\sigma_2$ or \dots or agent $i_k$ is in state $\sigma_k$".
In general, the nesccessary information of any statement can be encoded
as a function $f: \lbrace 1, \dots, m\rbrace \rightarrow 2^{\Sigma}$, 
while the set of letters $f(i) \subseteq \Sigma$ corresponds to the states the i-th 
agent. In other words, each agent can be  required by any states or not.
Consider the following statement: "In all configurations of length 3, 
the first agent is in state p or the first agent is in state q." 
Using a certain method, this statement can be encoded as a function 
$\lbrace 1 \mapsto \lbrace p,q \rbrace, 2 \mapsto \emptyset, 3 \mapsto \emptyset \rbrace$.
By simplifying this function to $\lbrace p,q \rbrace$  $\,\emptyset$ $\,\emptyset$, we can express the statement in words.

Without context, these words have no meaning or information.
Therefore, we use \textit{interpretation} to understand the statements that we encode.
For example, how can we answer the question: "Does the words p q q satisfied the statement $\lbrace p,q \rbrace$  $\,\emptyset$ $\,\emptyset$?".
The results can vary depending on the interpretation that we choose to use.
With the the interpretation "trap", one verify if 
$p \in \lbrace p,q \rbrace$, or $q \in \emptyset$, or $q \in \emptyset$.
It is necessary that at least one word in the configuration has a value in the inductive statement.
While the interpretation "siphon" check if
$p \notin \lbrace p,q \rbrace$, and $q \notin \emptyset$, and $q \notin \emptyset$.
In other words, it ensures that no configuration word has the same value as the statement.

\begin{theo}[Interpretation]{definition:interpretation}
    \textit{
        For any RTS $\mathcal{R} = \langle \Sigma, \mathcal{I}, \mathcal{T} \rangle$, we call 
        a pair $\langle \Gamma, \mathcal{V} \rangle$ an $\Gamma$-\textit{interpretation}
        where $\Gamma$ is a finite alphabet and $\mathcal{V}$ is a deterministic $\Sigma$-$\Sigma$-\textit{transducer}.
        In the following, we denote $ u \models I $ to indicate $ \langle u, I \rangle \in [[\mathcal{V}]]$.
     }
\end{theo}

\subsection*{Concrete interpretations}
In this thesis, we will explore three interpretations: \textit{trap}, \textit{siphon}, \textit{flow}, 
and will delve deeper into each of them for a better understanding.

\paragraph*{Traps} 
Let fix the size of the instance as $n$. We define any configuration 
$u_1 \dots u_n$ the set $\left\lgroup u \right\rgroup = \bigcup_{1 \leqslant i \leqslant n} \lbrace\langle i, u_i \rangle \rbrace$.
For any statement $I_1 \dots I_n$ we define a set $\left\lgroup I \right\rgroup = \bigcup_{1 \leqslant i \leqslant n} \lbrace i \rbrace \times I_i$.
The interpretation of a trap involves connecting a configuration u with a statement I if and only if
$\left\lgroup u \right\rgroup \cap \left\lgroup I \right\rgroup \neq \emptyset$.
Once a configuration has a value in the inductive statement, it can't remove all its values again - 
it gets "trapped". Formally, $u \models_{\mathcal{V}_{Trap}} I$ if and only if $\left\lgroup u \right\rgroup \bigcap \left\lgroup I \right\rgroup \neq \emptyset$.
For example, given the configuration $u = $ "n n n t", $v = $ "t n n n" and the statement $I =$ $\{n\} \,\, \emptyset \,\, \emptyset \,\, \emptyset$,
one can conclude that $u \models_{\mathcal{V}_{trap}} I$ and $v \not\models_{\mathcal{V}_{trap}} I$.
\begin{lem}[DFA for trap intepretation]{lem:trap}
    \textit{We denote with H all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \in I$ and M all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \notin I$.}

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (q_0)   {$q_0$}; 
        \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
         \path[->] 
         (q_0) edge  node {H} (q_1)
               edge [loop above] node {M} ()
         (q_1) edge [loop above] node {H, M} ();
     \end{tikzpicture}
\end{lem}

\paragraph*{Siphon}
According to the siphon interpretation, none of the values can be part of the configuration that satisfies I, as opposed to the trap interpretation.
Formally, $u \models_{\mathcal{V}_{siphon}} I$ if and only if  $\left\lgroup u \right\rgroup \bigcap \left\lgroup I \right\rgroup = \emptyset$.

\begin{lem}[DFA for siphon intepretation]{lem:siphon}
    \textit{Again, we denote with H all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \in I$ and M all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \notin I$.}

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial, accepting] (q_0)   {$q_0$}; 
        \node[state] (q_1) [right=of q_0] {$q_1$}; 
         \path[->] 
         (q_0) edge  node {H} (q_1)
               edge [loop above] node {M} ()
         (q_1) edge [loop above] node {H, M} ();
     \end{tikzpicture}
\end{lem}

\paragraph*{Flow}
The third and final interpretation we are interested in is called the flow interpretation $\mathcal{V}_{flow}$.
This interpretation requires that the letter of the configuration is included in the set in the same position in the encoded statement. 
It is important to note that this should occur at only one position.
Formally, $u \models_{\mathcal{V}_{siphon}} I$ if and only if  $\left|\left\lgroup u \right\rgroup \bigcap \left\lgroup I \right\rgroup\right| = 1$.
For instance, given the configuration $u = $ "n n n t", $v = $ "t t t t" and the statement $I =$ $\{t\} \,\, \{t\} \,\, \{t\} \,\, \{n, t\}$,
one can conclude that $u \models_{\mathcal{V}_{flow}} I$ and $v \not\models_{\mathcal{V}_{flow}} I$.
\begin{lem}[DFA for flow intepretation]{lem:flow}
    \textit{We also denote with H all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \in I$ and M all pairs in $\langle \sigma, I \rangle \in \Sigma \times 2^{\Sigma}$
    such that  $\sigma \notin I$.}

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (q_0)   {$q_0$}; 
        \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
        \node[state] (q_2) [right=of q_1] {$q_2$}; 
         \path[->] 
         (q_0) edge  node {H} (q_1)
               edge [loop above] node {M} ()
         (q_1) edge [loop above] node {M} ()
               edge  node {H} (q_2)
         (q_2) edge [loop above] node {H,M} ();
     \end{tikzpicture}
\end{lem}
\begin{theo}[Inductive statements]{definition:inductive_statements}
    \textit{
        For any given $\Gamma$-\textit{interpretation} for $\mathcal{R} = \langle \Sigma, \mathcal{I}, \mathcal{T} \rangle$, we define
        \[
        Inductive_{\mathcal{V}}(\mathcal{R}) = \lbrace I \in \Gamma^* | 
        \forall u \rightsquigarrow_\mathcal{T} \, . \, if \langle u, I \rangle
        \in [[\mathcal{V}]] \, then \, \langle v, I \rangle \in [[\mathcal{V}]] \rbrace
        \]
        \[=  \lbrace I \in \Gamma^* | 
        \forall u \rightsquigarrow_\mathcal{T} \, . \, if u \models I
            \, then \, v \models I \rbrace\]
    }
\end{theo}
For any RTS $\mathcal{R} = \langle \Sigma, \mathcal{I}, \mathcal{T} \rangle$
and any interpretation $\mathcal{V}$, any inductive
statement $I \in Inductive_{\mathcal{V}}(\mathcal{R})$
that is satisfied in one configuration w ($w \models I \rbrace$) is also satisfied
in all configurations that can be reached from w ($u \models I$ for all $w \rightsquigarrow_\mathcal{T}^{*} u$).

Let's consider the Token passing system example. 
The token passing algorithm can have a bad property known as "manytoken" (Automaton \ref{lem:manytoken}). 
This property refers to all the configurations where more than one agent holds the token simultaneously. 
In other words, if there are multiple tokens circulating at the same time, it is considered a "manytoken" situation.

\begin{lem}[DFA $\mathcal{B}$ for "manytoken"]{lem:manytoken}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
        \node[state,initial] (q_0)   {$q_0$}; 
        \node[state] (q_1) [right=of q_0] {$q_1$}; 
        \node[state, accepting] (q_2) [right=of q_1] {$q_2$}; 
         \path[->] 
         (q_0) edge  node {t} (q_1)
               edge [loop above] node {n} ()
         (q_1) edge [loop above] node {n} ()
         (q_1) edge  node {t} (q_2)
         (q_2) edge [loop above] node {n,t} ();
     \end{tikzpicture}
\end{lem}

Using the given token-passing system $\mathcal{R}$, a DFA $\mathcal{B}$ and $\mathcal{V}_{trap}$ interpretation, dodo-cpp can learn a 
regular set of inductive interpretations 
\[
    \{n\} \,\, \{n\} \,\, \{n\}^* \,\, (\{t\} \,\, \{n\} \,\, \{n\}^* \,\, | \,\, \{t\}) \subseteq Inductive_{\mathcal{V}_{trap}}(\mathcal{R})    
\] 
For the fixed length of configuration n = 4, all posible inductive statements are
\begin{gather*}
    \lbrace n \rbrace\,\,\,\, \lbrace n \rbrace \,\,\,\,  \lbrace n \rbrace \,\,\,\, \lbrace n \rbrace,\\
    \lbrace n \rbrace\,\,\,\, \lbrace n \rbrace \,\,\,\,  \lbrace n \rbrace \,\,\,\, \lbrace t \rbrace,\\
    \lbrace n \rbrace\,\,\,\, \lbrace n \rbrace \,\,\,\,  \lbrace t \rbrace \,\,\,\, \lbrace n \rbrace
\end{gather*}
It concludes that $v = $ "\textit{t t t n}" $\in \mathcal{L}(\mathcal{B})$ can not reached from the initial congfiguration
$u = $ "\textit{t n n n}" $\in \mathcal{L}(\mathcal{I})$ because $u$ satifies the statement
$I = \lbrace n \rbrace\,\,\,\, \lbrace n \rbrace \,\,\,\,  \lbrace n \rbrace \,\,\,\, \lbrace t \rbrace$,
but $v$ does not.

By this way, we can guarantee that no bad configuations can be reached
by checking both origin and the target configuations satisfied all
the inductive statements.

Now we will use inductive statements to establish a potential reachability relationship between two configurations.

\begin{theo}[Potential reachability]{definition:potential_reachability}
    \textit{
   Let $\mathcal{R} = \langle \Sigma, \mathcal{I}, \mathcal{T} \rangle$ be any \textit{RTS}
   and $\langle \Gamma, \mathcal{V} \rangle$ any interpretation.
   We write $u \Rightarrow_{\mathcal{V}} v$ if and only if $u \models_{\mathcal{V}} v$
   for all $I \in target_\mathcal{V}(u) \bigcap Inductive_\mathcal{V}(\mathcal{R})$.
   }
\end{theo}

\begin{lemma}\label{lemma:abstractly_reachable}
    
\end{lemma}
\textit{
    Let $\mathcal{R} = (\Sigma, I, T)$ be an RTS, $\langle \Gamma, \mathcal{V} \rangle$ an interpretation, 
    and S a NFA over the alphabet $\Gamma$. Then there exists a  $\Sigma-\Sigma-transducer$ C such that
}
\begin{equation}
    [[C]] = \left\lbrace \langle u,v\rangle \in \bigcup_{n \geq 0} \Sigma^n \times \Sigma^n \, | \, \forall I \in \mathcal{L}(S) \, . \, if \, u \, \models_{\mathcal{V}} \, I \, then \, v \models_{\mathcal{V}} I \right\rbrace
\end{equation}

Because regular languages are closed under complement, we can define $\overline{C}$ as followings:
\begin{lemma}\label{lemma:abstractly_reachable2}
    
\end{lemma}
\textit{
    Let $\mathcal{R} = (\Sigma, I, T)$ be an RTS, $\langle \Gamma, \mathcal{V} \rangle$ an interpretation, 
    and S a NFA over the alphabet $\Gamma$. Then there exists a  $\Sigma-\Sigma-transducer$ $\overline{C}$ such that
}
\begin{equation}
    [[\overline{C}]] = \left\lbrace \langle u,v\rangle \in \bigcup_{n \geq 0} \Sigma^n \times \Sigma^n \, | \, \exists I \in \mathcal{L}(S) \, . \, if \, u \, \models_{\mathcal{V}} \, I \, then \, v \not\models_{\mathcal{V}} I \right\rbrace
\end{equation}

Note that, these Lemmas have been proved in the previous work \cite*{Welzel2023InductiveSts}.
We will utilize them later for constructing the equivalent oracle in the implementation \autoref{chapter:implementation}.